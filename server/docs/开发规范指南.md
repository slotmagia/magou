# 角色权限管理系统开发规范指南

## 项目概述

本项目是基于 GoFrame v2 框架开发的角色权限管理系统，采用分层架构设计模式，主要提供完整的 RBAC (Role-Based Access Control) 权限管理功能。项目遵循现代软件开发的最佳实践，实现了高内聚低耦合的架构设计。

## 项目架构分析

### 1. 整体架构概览

基于我对项目的深入分析，该项目采用了经典的分层架构模式，具有以下特点：

- **入口层**: `main.go` 作为应用启动入口
- **命令层**: `internal/cmd/` 处理命令行参数和服务启动
- **路由层**: `internal/router/` 负责 API 路由注册和管理
- **控制器层**: `internal/controller/` 处理 HTTP 请求和响应
- **服务层**: `internal/service/` 定义业务接口，实现依赖注入
- **逻辑层**: `internal/logic/` 实现具体业务逻辑
- **模型层**: `internal/model/` 定义数据结构
- **工具层**: `utility/` 提供通用工具功能

### 2. 核心设计模式

#### 2.1 分层架构模式 (Layered Architecture)

```
┌─────────────────────────────────────────────────────┐
│                   路由层 (Router)                    │
│         负责URL路径映射和中间件绑定                   │
└───────────────────────┬─────────────────────────────┘
                        ↓
┌─────────────────────────────────────────────────────┐
│                 控制器层 (Controller)                │
│       处理HTTP请求，参数验证，调用服务层              │
└───────────────────────┬─────────────────────────────┘
                        ↓
┌─────────────────────────────────────────────────────┐
│                  服务层 (Service)                   │
│          定义业务接口，接口与实现分离                 │
└───────────────────────┬─────────────────────────────┘
                        ↓
┌─────────────────────────────────────────────────────┐
│                  逻辑层 (Logic)                     │
│            实现具体业务逻辑和业务规则                 │
└───────────────────────┬─────────────────────────────┘
                        ↓
┌─────────────────────────────────────────────────────┐
│                  模型层 (Model)                     │
│           定义数据结构和输入输出模型                  │
└─────────────────────────────────────────────────────┘
```

#### 2.2 依赖注入模式 (Dependency Injection)

项目通过服务注册机制实现依赖注入：

```go
// 服务接口定义
type IRole interface {
    GetRoleList(ctx context.Context, in *sysin.RoleListInp) (*sysout.RoleListModel, error)
    CreateRole(ctx context.Context, in *sysin.CreateRoleInp) (*sysout.RoleModel, error)
    UpdateRole(ctx context.Context, in *sysin.UpdateRoleInp) (*sysout.RoleModel, error)
    DeleteRole(ctx context.Context, in *sysin.DeleteRoleInp) error
}

// 服务注册
func init() {
    service.RegisterRole(NewRole())
}

// 服务获取
func Role() IRole {
    if localRole == nil {
        panic("implement not found for interface IRole")
    }
    return localRole
}
```

#### 2.3 工厂模式 (Factory Pattern)

通过 New\* 函数创建实例：

```go
// 控制器工厂
func NewRole() role.IRole {
    return &Role{}
}

// 业务逻辑工厂
func NewRole() *sRole {
    return &sRole{}
}
```

#### 2.4 中间件模式 (Middleware Pattern)

处理横切关注点：

```go
// 中间件链配置
group.Middleware(service.Middleware().ApiAuth)
group.Middleware(service.Middleware().CORS)
```

## 开发规范

### 1. 命名规范

#### 1.1 文件命名

- 使用小写字母和下划线：`role.go`
- 每个文件只包含一个主要类型或功能
- 测试文件以 `_test.go` 结尾

#### 1.2 包命名

- 使用小写字母，不使用下划线或驼峰：`role`、`middleware`
- 包名应简洁且有意义
- 避免使用泛型名称如 `util`、`common`

#### 1.3 接口和实现命名

- 接口名以 `I` 开头：`IRole`
- 实现类名以 `s` 开头：`sRole`
- 控制器直接使用功能名：`Role`

### 2. 目录结构规范

```
client-app/
├── internal/                    # 内部代码，不对外暴露
│   ├── api/                     # API接口定义
│   │   └── api/role/v1/         # 版本化的API定义
│   ├── cmd/                     # 命令行入口点
│   │   ├── cmd.go              # 主命令定义
│   │   ├── http.go             # HTTP服务命令
│   │   └── handler_shutdown.go # 优雅关闭处理
│   ├── consts/                  # 常量定义
│   │   ├── app.go              # 应用常量
│   │   ├── config.go           # 配置常量
│   │   ├── error.go            # 错误码常量
│   │   └── http.go             # HTTP相关常量
│   ├── controller/              # 控制器层
│   │   └── api/                # API控制器
│   │       └── role.go         # 角色管理控制器
│   ├── global/                  # 全局初始化
│   │   ├── init.go             # 全局初始化逻辑
│   │   └── httproutes.go       # HTTP路由配置
│   ├── library/                 # 内部公共库
│   │   ├── contexts/           # 上下文处理
│   │   ├── response/           # 响应处理
│   │   └── sdk/                # SDK集成
│   ├── logic/                   # 业务逻辑层
│   │   ├── api/                # API业务逻辑
│   │   ├── hook/               # 钩子函数
│   │   ├── middleware/         # 中间件实现
│   │   └── sys/                # 系统级逻辑
│   ├── model/                   # 数据模型
│   │   ├── input/sysin/        # 输入模型
│   │   ├── output/sysout/      # 输出模型
│   │   ├── entity/             # 数据实体
│   │   ├── context.go          # 上下文模型
│   │   ├── response.go         # 响应模型
│   │   └── view.go             # 视图模型
│   ├── router/                  # 路由注册
│   │   └── api.go              # API路由配置
│   └── service/                 # 服务接口定义
│       ├── api.role.go         # 角色服务接口
│       ├── hook.go             # 钩子服务
│       ├── middleware.go       # 中间件服务
│       └── view.go             # 视图服务
├── utility/                     # 工具包
│   ├── charset/                # 字符集处理
│   ├── encrypt/                # 加密工具
│   ├── simple/                 # 通用工具
│   └── validate/               # 验证工具
├── manifest/                    # 配置清单
│   └── config/                 # 配置文件
│       ├── config.yaml         # 主配置文件
│       └── config.example.yaml # 配置示例文件
├── sdk/                         # SDK目录
│   └── create.app.go           # 应用创建SDK
├── main.go                      # 应用入口
└── go.mod                       # 依赖管理
```

### 3. 分层开发规范

#### 3.1 控制器层 (Controller) 开发规范

控制器层主要职责：

- 接收和验证 HTTP 请求参数
- 调用服务层处理业务逻辑
- 处理特殊响应（重定向、直接输出等）
- 构造标准 HTTP 响应

```go
package api

import (
    "client-app/internal/api/api/role"
    v1 "client-app/internal/api/api/role/v1"
    "client-app/internal/service"
    "context"
)

// 控制器结构体
type Role struct{}

// 构造函数，返回接口类型
func NewRole() role.IRole {
    return &Role{}
}

// 获取角色列表控制器方法
func (c *Role) GetRoleList(ctx context.Context, req *v1.RoleListReq) (res *v1.RoleListRes, err error) {
    // 1. 调用服务层处理业务逻辑
    out, err := service.Role().GetRoleList(ctx, &req.RoleListInp)
    if err != nil {
        return nil, err
    }

    // 2. 构造标准JSON响应
    res = &v1.RoleListRes{
        RoleListModel: out,
    }

    return res, nil
}

// 创建角色控制器方法
func (c *Role) CreateRole(ctx context.Context, req *v1.CreateRoleReq) (res *v1.CreateRoleRes, err error) {
    // 1. 调用服务层处理业务逻辑
    out, err := service.Role().CreateRole(ctx, &req.CreateRoleInp)
    if err != nil {
        return nil, err
    }

    // 2. 构造标准JSON响应
    res = &v1.CreateRoleRes{
        RoleModel: out,
    }

    return res, nil
}
```

#### 3.2 服务层 (Service) 开发规范

服务层主要职责：

- 定义业务接口
- 提供依赖注入机制
- 接口与实现分离

```go
package service

import (
    "client-app/internal/model/input/sysin"
    "client-app/internal/model/output/sysout"
    "context"
)

// 角色服务接口定义
type IRole interface {
    GetRoleList(ctx context.Context, in *sysin.RoleListInp) (*sysout.RoleListModel, error)
    CreateRole(ctx context.Context, in *sysin.CreateRoleInp) (*sysout.RoleModel, error)
    UpdateRole(ctx context.Context, in *sysin.UpdateRoleInp) (*sysout.RoleModel, error)
    DeleteRole(ctx context.Context, in *sysin.DeleteRoleInp) error
    GetRoleMenus(ctx context.Context, in *sysin.RoleMenuInp) (*sysout.RoleMenuModel, error)
    UpdateRoleMenus(ctx context.Context, in *sysin.UpdateRoleMenuInp) error
}

// 全局变量存储服务实现
var localRole IRole

// 获取角色服务实例
func Role() IRole {
    if localRole == nil {
        panic("implement not found for interface IRole, forgot register?")
    }
    return localRole
}

// 注册角色服务实现
func RegisterRole(i IRole) {
    localRole = i
}
```

#### 3.3 逻辑层 (Logic) 开发规范

逻辑层主要职责：

- 实现具体业务逻辑
- 处理第三方服务集成
- 数据验证和转换
- 错误处理和日志记录

```go
package api

import (
    "client-app/internal/model/entity"
    "client-app/internal/model/input/sysin"
    "client-app/internal/model/output/sysout"
    "client-app/internal/service"
    "context"
    "github.com/gogf/gf/v2/database/gdb"
    "github.com/gogf/gf/v2/errors/gerror"
    "github.com/gogf/gf/v2/frame/g"
    "github.com/gogf/gf/v2/util/gconv"
)

// 业务逻辑实现结构体
type sRole struct{}

// 构造函数
func NewRole() *sRole {
    return &sRole{}
}

// 在init函数中注册服务
func init() {
    service.RegisterRole(NewRole())
}

// 获取角色列表业务逻辑实现
func (s *sRole) GetRoleList(ctx context.Context, in *sysin.RoleListInp) (*sysout.RoleListModel, error) {
    // 1. 构建查询条件
    m := g.DB().Model("roles").Where("deleted_at IS NULL")

    // 2. 按条件筛选
    if in.Name != "" {
        m = m.WhereLike("name", "%"+in.Name+"%")
    }
    if in.Code != "" {
        m = m.WhereLike("code", "%"+in.Code+"%")
    }
    if in.Status > 0 {
        m = m.Where("status", in.Status)
    }

    // 3. 获取总数
    totalCount, err := m.Count()
    if err != nil {
        return nil, gerror.Wrap(err, "获取角色总数失败")
    }

    // 4. 分页查询
    m = m.Order("sort ASC, id DESC").
        Limit(in.PageSize).
        Offset((in.Page - 1) * in.PageSize)

    var list []*entity.Role
    if err := m.Scan(&list); err != nil {
        return nil, gerror.Wrap(err, "查询角色列表失败")
    }

    // 5. 转换为输出模型
    var roleList []*sysout.RoleModel
    for _, role := range list {
        roleList = append(roleList, &sysout.RoleModel{
            Id:          role.Id,
            Name:        role.Name,
            Code:        role.Code,
            Description: role.Description,
            Status:      role.Status,
            Sort:        role.Sort,
            DataScope:   role.DataScope,
            Remark:      role.Remark,
            CreatedAt:   role.CreatedAt,
            UpdatedAt:   role.UpdatedAt,
        })
    }

    return &sysout.RoleListModel{
        List:     roleList,
        Total:    int64(totalCount),
        Page:     in.Page,
        PageSize: in.PageSize,
    }, nil
}

// 创建角色业务逻辑实现
func (s *sRole) CreateRole(ctx context.Context, in *sysin.CreateRoleInp) (*sysout.RoleModel, error) {
    // 1. 验证角色编码唯一性
    count, err := g.DB().Model("roles").Where("code", in.Code).Where("deleted_at IS NULL").Count()
    if err != nil {
        return nil, gerror.Wrap(err, "验证角色编码失败")
    }
    if count > 0 {
        return nil, gerror.New("角色编码已存在")
    }

    // 2. 创建角色记录
    result, err := g.DB().Model("roles").Data(g.Map{
        "name":        in.Name,
        "code":        in.Code,
        "description": in.Description,
        "status":      in.Status,
        "sort":        in.Sort,
        "data_scope":  in.DataScope,
        "remark":      in.Remark,
        "created_by":  gconv.Uint64(ctx.Value("userId")),
        "updated_by":  gconv.Uint64(ctx.Value("userId")),
        "created_at":  gtime.Now(),
        "updated_at":  gtime.Now(),
    }).Insert()

    if err != nil {
        return nil, gerror.Wrap(err, "创建角色失败")
    }

    // 3. 获取新创建的角色ID
    roleId, err := result.LastInsertId()
    if err != nil {
        return nil, gerror.Wrap(err, "获取角色ID失败")
    }

    // 4. 查询并返回创建的角色信息
    var role *entity.Role
    err = g.DB().Model("roles").Where("id", roleId).Scan(&role)
    if err != nil {
        return nil, gerror.Wrap(err, "查询角色信息失败")
    }

    return &sysout.RoleModel{
        Id:          role.Id,
        Name:        role.Name,
        Code:        role.Code,
        Description: role.Description,
        Status:      role.Status,
        Sort:        role.Sort,
        DataScope:   role.DataScope,
        Remark:      role.Remark,
        CreatedAt:   role.CreatedAt,
        UpdatedAt:   role.UpdatedAt,
    }, nil
}
```

#### 3.4 模型层 (Model) 开发规范

模型层按输入输出分离：

**输入模型 (input/sysin/)**:

```go
package sysin

import (
    "context"
    "github.com/gogf/gf/v2/frame/g"
)

// 角色列表查询参数
type RoleListInp struct {
    Page     int    `json:"page"     v:"min:1"              d:"1"          description:"页码"`
    PageSize int    `json:"pageSize" v:"min:1|max:100"      d:"20"         description:"每页数量"`
    Name     string `json:"name"     v:"length:0,50"                       description:"角色名称"`
    Code     string `json:"code"     v:"length:0,50"                       description:"角色编码"`
    Status   int    `json:"status"   v:"in:0,1,2"           d:"0"          description:"状态：0=全部 1=启用 2=禁用"`
}

// 创建角色输入参数
type CreateRoleInp struct {
    Name        string `json:"name"        v:"required|length:1,50#角色名称不能为空|角色名称长度不能超过50字符"`
    Code        string `json:"code"        v:"required|length:1,50#角色编码不能为空|角色编码长度不能超过50字符"`
    Description string `json:"description" v:"length:0,200#角色描述长度不能超过200字符"`
    Status      int    `json:"status"      v:"required|in:1,2#状态不能为空|状态值不正确"`
    Sort        int    `json:"sort"        v:"min:0#排序号不能小于0"`
    DataScope   int    `json:"dataScope"   v:"required|in:1,2,3,4,5#数据权限范围不能为空|数据权限范围值不正确"`
    Remark      string `json:"remark"      v:"length:0,500#备注长度不能超过500字符"`
}

// 参数过滤和验证方法
func (in *CreateRoleInp) Filter(ctx context.Context) error {
    return g.Validator().Data(in).Run(ctx)
}
```

**输出模型 (output/sysout/)**:

```go
package sysout

import "github.com/gogf/gf/v2/os/gtime"

// 角色模型
type RoleModel struct {
    Id          int64       `json:"id"`          // 角色ID
    Name        string      `json:"name"`        // 角色名称
    Code        string      `json:"code"`        // 角色编码
    Description string      `json:"description"` // 角色描述
    Status      int         `json:"status"`      // 状态：1=启用 2=禁用
    Sort        int         `json:"sort"`        // 排序号
    DataScope   int         `json:"dataScope"`   // 数据权限范围
    Remark      string      `json:"remark"`      // 备注说明
    CreatedAt   *gtime.Time `json:"createdAt"`   // 创建时间
    UpdatedAt   *gtime.Time `json:"updatedAt"`   // 更新时间
}

// 角色列表响应模型
type RoleListModel struct {
    List     []*RoleModel `json:"list"`     // 角色列表
    Total    int64        `json:"total"`    // 总数
    Page     int          `json:"page"`     // 当前页码
    PageSize int          `json:"pageSize"` // 每页数量
}
```

#### 3.5 中间件开发规范

```go
package middleware

import "github.com/gogf/gf/v2/net/ghttp"

// 中间件结构体
type sMiddleware struct{}

// CORS跨域中间件
func (s *sMiddleware) CORS(r *ghttp.Request) {
    r.Response.CORSDefault()
    r.Middleware.Next()
}

// API认证中间件
func (s *sMiddleware) ApiAuth(r *ghttp.Request) {
    // 1. 获取认证信息
    token := r.Header.Get("Authorization")

    // 2. 验证逻辑
    if token == "" {
        r.Response.WriteJson(g.Map{
            "code": -1,
            "msg":  "缺少认证信息",
        })
        r.Exit()
        return
    }

    // 3. 继续执行下一个中间件或处理器
    r.Middleware.Next()
}
```

#### 3.6 路由注册规范

```go
package router

import (
    "client-app/internal/consts"
    "client-app/internal/controller/api"
    "client-app/internal/service"
    "context"
    "github.com/gogf/gf/v2/net/ghttp"
)

// API路由注册
func Api(ctx context.Context, group *ghttp.RouterGroup) {
    group.Group(simple.RouterPrefix(ctx, consts.AppApi), func(group *ghttp.RouterGroup) {
        // 1. 绑定控制器
        group.Bind(
            api.NewPayment(),
            api.NewRole(),
        )

        // 2. 设置中间件（对所有路由生效）
        group.Middleware(service.Middleware().ApiAuth)

        // 3. 再次绑定（应用中间件后的路由）
        group.Bind()
    })
}
```

### 4. 配置管理规范

#### 4.1 配置文件结构

```yaml
# manifest/config/config.yaml

# 系统配置
system:
  appName: "hotgo"
  appVersion: "1.0.0"
  mode: "develop"

# 服务器配置
server:
  merchantId: 1001
  ApiKey: "5787c7a121190011fac8376b1d3e0396"
  domain: "localhost"
  address: ":8888"

# 支付宝配置
alipay:
  appId: "2021004194625273"
  privateKey: "MII..."
  publicKey: "MII..."
  notifyURL: "/pay/notify"
  returnURL: "/pay/return"
  sandbox: true
```

#### 4.2 配置读取方式

```go
// 1. 基本配置读取
appId, err := g.Cfg().Get(ctx, "alipay.appId")
if err != nil || appId.String() == "" {
    return nil, gerror.New("未配置支付宝APPID")
}

// 2. 带默认值的配置读取
isSandbox, err := g.Cfg().Get(ctx, "alipay.sandbox")
if err != nil {
    isSandbox.Set(false)  // 设置默认值
}

// 3. 必须配置验证
privateKey, err := g.Cfg().Get(ctx, "alipay.privateKey")
if err != nil || privateKey.String() == "" {
    return nil, gerror.New("未配置支付宝私钥")
}
```

### 5. 错误处理规范

#### 5.1 错误创建和传递

```go
// 1. 创建简单错误
return nil, gerror.New("错误信息")

// 2. 创建格式化错误
return nil, gerror.Newf("初始化支付宝客户端失败: %v", err)

// 3. 在控制器层处理错误
out, err := service.Payment().CreateOrder(ctx, &req.CreateOrderInp)
if err != nil {
    return nil, err  // 直接返回，由框架统一处理
}

// 4. 记录关键错误日志
g.Log().Errorf(ctx, "处理支付宝通知失败: %v", err)
```

#### 5.2 业务状态定义

```go
// 订单状态常量
const (
    OrderStatusPending    = "pending"    // 待支付
    OrderStatusProcessing = "processing" // 处理中
    OrderStatusSuccess    = "success"    // 支付成功
    OrderStatusClosed     = "closed"     // 已关闭
    OrderStatusFailed     = "failed"     // 支付失败
    OrderStatusRefunding  = "refunding"  // 退款中
    OrderStatusRefunded   = "refunded"   // 已退款
)
```

## 开发流程规范

### 1. 新功能开发流程

开发一个新的支付功能时，按以下步骤进行：

1. **需求分析**: 明确功能需求、支付方式、业务流程
2. **接口设计**: 设计 API 接口和数据模型
3. **分层实现**:
   - 创建输入输出模型
   - 定义服务接口
   - 实现业务逻辑
   - 编写控制器
   - 注册路由
4. **测试验证**: 单元测试和集成测试
5. **文档更新**: 更新 API 文档和使用说明

### 2. 扩展新支付方式示例

以添加微信支付为例：

#### 2.1 创建输入模型

```go
// internal/model/input/sysin/wechat.go
type WechatPayInp struct {
    OrderNo     string `json:"orderNo" v:"required#订单号不能为空"`
    Subject     string `json:"subject" v:"required#商品标题不能为空"`
    TotalAmount string `json:"totalAmount" v:"required#金额不能为空"`
    PayMethod   string `json:"payMethod" v:"required|in:wechat_app,wechat_h5,wechat_jsapi#支付方式不正确"`
    OpenId      string `json:"openId"`  // JSAPI支付需要
}
```

#### 2.2 创建输出模型

```go
// internal/model/output/sysout/wechat.go
type WechatOrderModel struct {
    OrderNo       string `json:"orderNo"`
    PayMethod     string `json:"payMethod"`
    PrepayId      string `json:"prepayId"`
    PayContent    string `json:"payContent"`
    CodeUrl       string `json:"codeUrl,omitempty"`
    MwebUrl       string `json:"mwebUrl,omitempty"`
}
```

#### 2.3 定义服务接口

```go
// internal/service/api.wechat.go
type IWechat interface {
    CreateOrder(ctx context.Context, in *sysin.WechatPayInp) (*sysout.WechatOrderModel, error)
    HandleWechatNotify(ctx context.Context, req *http.Request) (string, error)
}

var localWechat IWechat

func Wechat() IWechat {
    if localWechat == nil {
        panic("implement not found for interface IWechat")
    }
    return localWechat
}

func RegisterWechat(i IWechat) {
    localWechat = i
}
```

#### 2.4 实现业务逻辑

```go
// internal/logic/api/wechat.go
type sWechat struct{}

func NewWechat() *sWechat {
    return &sWechat{}
}

func init() {
    service.RegisterWechat(NewWechat())
}

func (s *sWechat) CreateOrder(ctx context.Context, in *sysin.WechatPayInp) (*sysout.WechatOrderModel, error) {
    // 微信支付业务逻辑实现
    // 1. 获取微信支付配置
    // 2. 初始化微信支付客户端
    // 3. 根据支付方式调用对应接口
    // 4. 返回支付结果
}
```

#### 2.5 编写控制器

```go
// internal/controller/api/wechat.go
type Wechat struct{}

func NewWechat() wechat.IWechat {
    return &Wechat{}
}

func (c *Wechat) CreateOrder(ctx context.Context, req *v1.WechatReq) (*v1.WechatRes, error) {
    out, err := service.Wechat().CreateOrder(ctx, &req.WechatPayInp)
    if err != nil {
        return nil, err
    }

    res := &v1.WechatRes{}
    res.WechatOrderModel = *out
    return res, nil
}
```

#### 2.6 注册路由

```go
// internal/router/api.go
func Api(ctx context.Context, group *ghttp.RouterGroup) {
    group.Group(simple.RouterPrefix(ctx, consts.AppApi), func(group *ghttp.RouterGroup) {
        group.Bind(
            api.NewPayment(),
            api.NewWechat(),  // 新增微信支付
        )
        group.Middleware(service.Middleware().ApiAuth)
        group.Bind()
    })
}
```

### 3. 代码提交规范

使用规范的 Git 提交信息格式：

```bash
# 提交信息格式
<type>(<scope>): <subject>

# 类型说明
feat: 新功能
fix: 修复bug
docs: 文档更新
style: 代码格式修改
refactor: 代码重构
test: 测试相关
chore: 构建过程或辅助工具的变动

# 示例
feat(payment): 添加支付宝APP支付功能
fix(middleware): 修复CORS跨域问题
docs(api): 更新支付接口文档
refactor(service): 重构支付服务接口
```

## 测试规范

### 1. 单元测试

```go
// internal/logic/api/payment_test.go
package api

import (
    "client-app/internal/model/input/sysin"
    "context"
    "testing"
    "github.com/stretchr/testify/assert"
)

func TestCreateOrder(t *testing.T) {
    ctx := context.Background()

    // 准备测试数据
    input := &sysin.CreateOrderInp{
        OrderNo:     "TEST001",
        Subject:     "测试商品",
        TotalAmount: "0.01",
        PayMethod:   "alipay_app",
    }

    // 执行测试
    payment := NewPayment()
    result, err := payment.CreateOrder(ctx, input)

    // 验证结果
    assert.NoError(t, err)
    assert.NotNil(t, result)
    assert.Equal(t, "TEST001", result.OrderNo)
    assert.Equal(t, "alipay_app", result.PayMethod)
    assert.NotEmpty(t, result.PayContent)
}

func TestCreateOrderWithInvalidPayMethod(t *testing.T) {
    ctx := context.Background()

    input := &sysin.CreateOrderInp{
        OrderNo:     "TEST002",
        Subject:     "测试商品",
        TotalAmount: "0.01",
        PayMethod:   "invalid_method",
    }

    payment := NewPayment()
    result, err := payment.CreateOrder(ctx, input)

    assert.Error(t, err)
    assert.Nil(t, result)
    assert.Contains(t, err.Error(), "不支持的支付方式")
}
```

### 2. 集成测试

```bash
# 启动测试服务
gf run main.go

# 测试创建订单接口
curl -X POST "http://localhost:8888/api/payment/create" \
  -H "Content-Type: application/json" \
  -d '{
    "orderNo": "TEST001",
    "subject": "测试商品",
    "totalAmount": "0.01",
    "payMethod": "alipay_app"
  }'

# 测试支付宝通知接口
curl -X POST "http://localhost:8888/api/payment/notify/alipay" \
  -H "Content-Type: application/x-www-form-urlencoded" \
  -d 'trade_status=TRADE_SUCCESS&out_trade_no=TEST001&trade_no=2023123112345678'
```

### 3. 性能测试

```bash
# 使用 Apache Bench 进行压力测试
ab -n 1000 -c 10 -H "Content-Type: application/json" \
  -p test_data.json \
  http://localhost:8888/api/payment/create
```

## 安全规范

### 1. 配置安全

```yaml
# 敏感配置使用环境变量
alipay:
  appId: "${ALIPAY_APP_ID}"
  privateKey: "${ALIPAY_PRIVATE_KEY}"
  publicKey: "${ALIPAY_PUBLIC_KEY}"
```

### 2. 接口安全

```go
// API签名验证中间件
func (s *sMiddleware) ApiVerify(r *ghttp.Request) {
    // 1. 获取请求参数
    timestamp := r.Get("timestamp")
    signature := r.Get("signature")

    // 2. 验证时间戳（防重放攻击）
    if math.Abs(float64(time.Now().Unix()-timestamp.Int64())) > 300 {
        r.Response.WriteJson(g.Map{"code": -1, "msg": "请求已过期"})
        r.Exit()
        return
    }

    // 3. 验证签名
    if !verifySignature(r.GetMap(), signature.String()) {
        r.Response.WriteJson(g.Map{"code": -1, "msg": "签名验证失败"})
        r.Exit()
        return
    }

    r.Middleware.Next()
}
```

### 3. 支付安全

```go
// 支付宝异步通知验签
func (s *sPayment) HandleAlipayNotify(ctx context.Context, req *http.Request) (string, error) {
    // 1. 解析通知参数
    bm, err := alipay.ParseNotifyToBodyMap(req)
    if err != nil {
        return "", gerror.Newf("解析通知参数失败: %v", err)
    }

    // 2. 验证签名
    aliPayPublicKey, _ := g.Cfg().Get(ctx, "alipay.publicKey")
    ok, err := alipay.VerifySign(aliPayPublicKey.String(), bm)
    if err != nil || !ok {
        return "", gerror.New("签名验证失败")
    }

    // 3. 处理业务逻辑
    // ...

    return "success", nil
}
```

## 性能优化指南

### 1. 代码层面优化

- **连接池管理**: 使用连接池管理第三方服务连接
- **缓存使用**: 合理使用缓存减少重复计算和请求
- **异步处理**: 使用 goroutine 处理耗时操作
- **避免内存泄漏**: 及时释放资源，避免 goroutine 泄漏

```go
// 使用连接池
var httpClient = &http.Client{
    Timeout: 30 * time.Second,
    Transport: &http.Transport{
        MaxIdleConns:        100,
        MaxIdleConnsPerHost: 10,
        IdleConnTimeout:     90 * time.Second,
    },
}

// 异步处理通知
go func() {
    defer func() {
        if r := recover(); r != nil {
            g.Log().Errorf(ctx, "处理通知异常: %v", r)
        }
    }()

    // 处理业务逻辑
    processNotification(ctx, data)
}()
```

### 2. 架构层面优化

- **负载均衡**: 使用 Nginx 或云负载均衡分散请求压力
- **服务降级**: 实现熔断机制，防止雪崩效应
- **监控告警**: 集成监控系统，及时发现性能问题
- **合理超时**: 设置合理的超时时间，避免长时间阻塞

## 监控和日志规范

### 1. 日志记录

```go
// 关键操作日志
g.Log().Infof(ctx, "创建订单成功: 订单号=%s, 金额=%s, 支付方式=%s",
    orderNo, amount, payMethod)

// 错误日志
g.Log().Errorf(ctx, "支付宝通知处理失败: 订单号=%s, 错误=%v",
    orderNo, err)

// 调试日志
g.Log().Debugf(ctx, "支付参数: %+v", payParams)
```

### 2. 链路追踪

```go
// 在global/init.go中已集成Jaeger
func InitTrace(ctx context.Context) {
    if !g.Cfg().MustGet(ctx, "jaeger.switch").Bool() {
        return
    }

    tp, err := jaeger.Init(simple.AppName(ctx), g.Cfg().MustGet(ctx, "jaeger.endpoint").String())
    if err != nil {
        g.Log().Fatal(ctx, err)
    }

    // 在服务关闭时清理资源
    simple.Event().Register(consts.EventServerClose, func(ctx context.Context, args ...interface{}) {
        _ = tp.Shutdown(ctx)
        g.Log().Debug(ctx, "jaeger closed ..")
    })
}
```

## 总结

本开发规范指南详细分析了支付通道服务的架构设计，定义了完整的开发规范，包括：

1. **架构设计**: 分层架构、依赖注入、工厂模式、中间件模式
2. **开发规范**: 命名规范、目录结构、分层开发规范
3. **开发流程**: 新功能开发、扩展支付方式、代码提交规范
4. **质量保证**: 测试规范、安全规范、性能优化
5. **运维支持**: 监控日志、链路追踪

遵循这些规范可以确保：

- **代码质量**: 统一的编码风格和规范
- **可维护性**: 清晰的分层架构和职责分离
- **可扩展性**: 易于添加新的支付方式和功能
- **稳定性**: 完善的错误处理和安全机制
- **可观测性**: 完整的日志记录和监控

开发者在进行项目开发时，应严格按照本指南执行，确保项目的一致性和高质量。随着项目发展和技术更新，本指南也会持续完善和更新。
